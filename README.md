Умные указатели. Smart pointers #130
для авто освобождения памяти
template<typename T>
class SmartPointer//для автоматизации работы с указателем
{
public:
	SmartPointer(T *ptr)//б.получать указатель на какой-то объект, памяьб на который мы выделили
		//и адрес в памяти, на который указ-т этот указ-ь мы б.записывать в наш ук-ль
		//что лежит в private секции и здесь б.его хранить
		//
	{
		this->ptr = ptr;

	}
	~SmartPointer()//здесмь обяз-но освобождаем место
	{
     delete ptr;
	}
	//чт.получить доступ к данным лежащим в указателе(а он в секции private)
	//и доступ затруднен, мы  перегрузим оператор звездочка.
	T& operator*()//возвращаем именно ссылка на тип T, тк хотим менно данные изменить
		//далее название того, что перегружаем - * и скобки
	{
		return *ptr;//возвращаем разымен-е данные
	}

private:
	T *ptr;//сможет работать с любым типом. Ч-з него мы м. получить доступ в памяти,где
	//хранятся данные,под котороые б. выделено место
};

int main()
{
	SmartPointer<int> pointer = new int(5);//new int(5) такая запись возвращает  указатель
	//в момент уничтожения нашего объекта вызовется дестр-р и освободит память.
	//*pointer = 5656;
	cout << *pointer << endl;//т к мы перегрузили указ-ль, то м получить данные путем разыменования указателя


	return 0;
}



auto_ptr | unique_ptr | shared_ptr | Умные указатели. Изучение С++ для начинающих. Урок #131]

#include<memory>//класс который содержит умные указатели
template<typename T>
class SmartPointer//для автоматизации работы с указателем
{
public:
	SmartPointer(T *ptr)//б.получать указатель на какой-то объект, памяьб на который мы выделили
		//и адрес в памяти, на который указ-т этот указ-ь мы б.записывать в наш ук-ль
		//что лежит в private секции и здесь б.его хранить
		//
	{
		this->ptr = ptr;

	}
	~SmartPointer()//здесмь обяз-но освобождаем место
	{
		delete ptr;
	}
	//чт.получить доступ к данным лежащим в указателе(а он в секции private)
	//и доступ затруднен, мы  перегрузим оператор звездочка.
	T& operator*()//возвращаем именно ссылка на тип T, тк хотим менно данные изменить
		//далее название того, что перегружаем - * и скобки
	{
		return *ptr;//возвращаем разымен-е данные
	}

private:
	T *ptr;//сможет работать с любым типом. Ч-з него мы м. получить доступ в памяти,где
	//хранятся данные,под котороые б. выделено место
};
int main()
{
	SmartPointer<int> sp1 = new int(5); 
	SmartPointer<int> sp2 = sp1;//ссыл-ся н аодну и ту же ячейку памяти. И когда б. удаление 
	//деструктором, то б. утечка, т к попытка удалит одну и ту же обл памяти
	auto_ptr<int>ap1(new int(5));//те же записи, что выше олько с auto_ptr
	auto_ptr<int>ap2(ap1);//в этом случае б. работать без утечки

	unique_ptr<int> p1(new int(5));
	unique_ptr<int> p2;
	p2 = move(p1);//присвоили p2  в ф-цию move. В итоге в начале p1- хранит 5, а  p2-
	//пустой, но после отрабокт ф-ции, p1 - пустой, а p2 - содержит 5
	p2.swap(p1);//аналог move, рез-т тот же

	int *p = p1.get();
	int*p = new int(5);
	unique_ptr<int> p1(p);
	p1.reset();
	p1.release();//данные остаются в памяти, но указ-ль о низ забывает , 
	//становится пустым(P1)
	shared_ptr<int> p1(new int(3));



	return 0;
}
